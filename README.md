# Вопросы по асинхронному программированию для собеседований

1. Как мы можем написать код избегая блокирования цикла событий?
2. Как мы можем вывести рантайм из состояния блокировки цикла событий из того же процесса?
3. Что такое «callback hell» и как мы можем его избежать?
4. Что такое асинхронные генераторы и итераторы, как они работают и каковы варианты их использования?
5. Как мы обрабатываем ошибки в асинхронном коде?
6. Когда try/catch ловит асинхронные ошибки, а когда нет?
7. Какая асинхронная абстракция поддерживает флаг `captureRejections` и зачем он нужен?
8. Как мы можем избежать потери шагов стек трейса, улучшить дебаг и понимание потока управления с помощью async/await?
9. Как мы можем отменить асинхронные операции?
10. Какая разница между асинхронными контрактами: callbacks, events, async/await, promises и т.п.?
11. Как связаны асинхронные контракты (callbacks, events, async/await, promises) и можно ли вывести употребления устаревшие?
12. Какая разница между `Promise.all()` и `Promise.allSettled()`?
13. Какая разница между `f2` и `f3` в таком выражении: `promiseInstance.then(f1, f2).catch(f3)`?
14. Когда и почему мы можем иметь несколько вызовов catch: `promiseInstance.catch(f1).catch(f2).catch(f3)`?
15. Почему у нас есть метод `Promise` `finally` и какие могут быть варианты его использования?
16. Как мы можем написать асинхронный код с помощью синхронных генераторов? Какие преимущества и недостатки этого подхода?
17. Приведите примеры использования `yield` в асинхронном программировании. Как это переписать на современном JavaScript?
18. Опишите отличия между Web Workers, Shared Workers и Worker Threads.
19. Расскажите, что такое микротаски и макротаски и как они связаны с циклом событий?
20. Что такое Worker Threads в Node.js и как мы можем их использовать?
21. Как мы можем измерить производительность I/O операций и использование ими ресурсов?
22. Что такое `process.hrtime` и `process.hrtime.bigint()`? В чем отличие?
23. Расскажите нам о таком API Node.js: `const { performance } = require('node:perf_hooks');`
24. Как мы можем эффективно обрабатывать асинхронные запросы API на клиентской стороне, которые возвращают большие объемы данных?
25. Как мы можем эффективно обрабатывать запросы API на стороне сервера, асинхронно возвращающие большие объемы данных?
26. Как мы можем обеспечить изоляцию состояния между разными асинхронными запросами в одном процессе Node.js?
27. Что такое CLS (continuation local storage) и есть ли у нас современная замена этой технике в Node.js?
28. Какие фазы цикла событий связаны с незавершенными обратными вызовами?
29. Расскажите о контракте `Thenable` и его отношении к `Promise`.
30. Как мы можем увязать данные (состояние, коллекции, структуры данных) с цепочкой асинхронных вызовов?
31. Как мы можем отслеживать цепочку асинхронных вызовов от внешних запросов (идущих от вызова API через HTTP, UDP, IPC, WebSocket)?
32. Как мы можем обеспечить безопасную обработку конкурирующих запросов к ресурсу?
33. Зачем нам нужны блокировки, например Web Locks API?
34. Как мы можем использовать примитивы параллельного программирования (semaphore, mutex, critical section и т.п.) в асинхронном программировании?
35. Расскажите о парадигме «Реактивное программирование».
36. Какая разница между подходами стримов и сигналов в реактивном программировании?
37. Как мы можем избегать deadlocks или выходить из такого состояния в асинхронном коде?
38. Как мы можем обеспечить высокую доступность в асинхронных программах?
39. Как мы можем обрабатывать асинхронные операции, которые зависят друг от друга (параллельное и последовательное исполнение)?
40. Что такое «race condition» и как мы можем этого избегать?
41. Предложите случаи использования для `Promise.race`, `Promise.all` и `Promise.allSettled`.
42. Что такое throttling и debouncing в контексте асинхронного программирования?
43. Как мы можем зашейпить (ограничить) асинхронные вызовы (например, чтобы лучше обрабатывать поток запросов к API)?
44. Какие абстракции, реализующие шаблон `Observable`, мы имеем JavaScript для серверного и клиентского кода?
45. Опишите подход `Signals` для реактивного программирования.
46. ​​Почему Streams полезны для улучшения семантики кода как абстракции высокого уровня?
47. Что такое back pressure?
48. Какая разница между созданием `Stream` с помощью `extends` и передачей функции `read`, `write` или `transform` к конструктору?
49. Почему у нас есть три набора таймеров: в глобальном контексте (например, `setTimeout`), `node:timers` и `node:timers.promises`?
50. Какие promisified API вы знаете, и как мы можем вручную промисифицировать другие API?
51. Расскажите о тестировании асинхронного кода.
52. Почему TypeScript не может описать асинхронные контракты во всем аспектам?
53. Как мы можем предотвратить утечки памяти (memory leaks) в асинхронном коде?
54. Какие лучшие практики управления параллелизмом в JavaScript?
55. Как мы можем использовать async/await вместе с `EventEmitter`?
56. Какая разница между `EventEmitter` и `EventTarget`?
57. Какова роль ключевого слова `await` в асинхронных функциях?
58. Что произойдет, если мы используем `await` не с `Promise` значениями (или выражениями)?
59. Как мы можем добавить тайм-ауты в асинхронных операциях (например для await)?
60. Для чего используется метод `process.nextTick`?
61. Как мы можем создать собственные асинхронные итераторы и какие варианты их использования?
62. Каковы преимущества и недостатки использования асинхронных библиотек сторонних разработчиков, таких как полифилы для `Promise` или `async.js`?
63. Как мы можем работать с асинхронным кодом в устаревших системах?
64. Какая разница между асинхронными, параллельными и I/O операциями?
65. Как мы можем эффективно распараллелировать I/O операции?
66. Как мы можем обеспечить потокобезопасность в асинхронном программировании?
67. Как `Atomics` связано с асинхронным и параллельным программированием? Зачем они используются?
68. Как мы можем оптимизировать асинхронный код для производительности (performance)?
69. Как мы можем обрабатывать повторы (retries) вызовов, вычислений, доступа к ресурсам в асинхронном программировании?
70. Каковы типичные подводные камни асинхронного программирования?
71. Как мы можем использовать async/await функции вместе с `Array.prototype.map`?
72. Как мы можем эффективно дебожить асинхронный код?
73. Как можно обеспечить согласованность данных в асинхронных операциях?
74. Каковы преимущества использования `async/await` над обратными вызовами (callbacks)?
75. Какие операции нельзя перевести с обратных вызовов (callbacks) на синтаксис `async/await` но можно на `Promises`?
76. Предложите кейсы использования для `AbortSignal.timeout()`. Какие известные API это поддерживают?
77. Где и для каких целей мы можем использовать `AbortSignal.any(iterable)`?
78. Какие различия между методами `Promise`: `resolve` и `reject`?
79. Как мы можем обрабатывать ошибки в `Promise.all`?
80. Как мы можем делать chain (последовательно композировать) асинхронные операции? Пожалуйста, предложите случаи тех контрактов, которые знаете.
81. Какова роль event loop в асинхронном программировании?
82. Как мы можем обрабатывать длительные асинхронные операции? (Процессы могут прекратить работу, результаты могут устареть и т.д.)
83. Как мы можем обеспечить идемпотентность в асинхронных операциях и когда нам это нужно?
84. Можем ли мы написать приложение реального времени на JavaScript и асинхронном программировании?
85. Как мы можем обеспечить порядок асинхронных операций? Пожалуйста, подскажите, когда мы можем иметь проблемы.
86. Как мы можем работать с асинхронным кодом в системах высокой доступности?
87. Что такое observables и как мы можем их использовать в JavaScript?
88. Каковы основные проблемы обработки состояния в асинхронном коде в stateful системах?
89. Когда мы можем использовать внутренние асинхронные очереди и когда нам нужны внешние системы очередей?
90. Как мы можем использовать асинхронные функции с кэшированием, memoization и повторными вычислениями для обновления состояния?
91. Как мы можем использовать асинхронные функции с подключениями к базе данных? Приведите примеры.
92. Как мы можем отделить асинхронный код от бизнес-логики и почему нам это нужно делать?
93. Каково влияние асинхронного кода на операции, связанные с процессором, а не на I/O операции?
94. Какие вещи в асинхронном программировании следует делать из соображений безопасности?
95. Как мы можем реализовать очередь с приоритетами для асинхронных задач?
96. Как можно использовать асинхронные функции с операциями файловой системы?
97. Как мы можем обеспечить атомарность в асинхронных операциях и зачем?
98. Какие есть компромиссы при віборе между использованием `Promise` и `async/await`?
99. Какая разница между классическим асинхронным программированием и подходом RxJS?
100. Что такое асинхронные коллекции и как они могут улучшить работу разработчика?

## Ссылки

- [❓ Каталог вопросов для интервью](https://github.com/tshemsedinov/Interview-Questions)
- [🔁 Курс Async 2024](https://github.com/HowProgrammingWorks/Index/blob/master/Courses/Async-2024.md)
- [🚀 Курс Node.js 2024](https://github.com/HowProgrammingWorks/Index/blob/master/Courses/NodeJS-2024.md)
- [🤖 Self Assessment](https://github.com/HowProgrammingWorks/SelfAssessment)
