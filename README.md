# Питання з асинхронного програмування для співбесід

1. Як ми можемо написати код, щоб уникнути блокування циклу подій?
2. Як ми можемо вивести рантайм зі стану блокування циклу подій, з того самого процесу?
3. Що таке «callback hell» і як ми можемо його уникнути?
4. Що таке асинхронні генератори та ітератори, як вони працюють і які варіанти їх використання?
5. Як ми обробляємо помилки в асинхронному коді?
6. Коли try/catch хопає асинхронні помилки, а коли ні?
7. Яка асинхронна абстракція підтримує флаг `captureRejections` і для чого він потрібен?
8. Як ми можемо уникнути втрати кроків стек трейсу, покращити дебаг та розуміння потоку керування за допомогою async/await?
9. Як ми можемо відмінити асинхронні операції?
10. Яка різниця між асинхронними контрактами: callbacks, events, async/await, promises, тощо?
11. Як пов’язані асинхронні контракти (callbacks, events, async/await, promises) і чи можна вивести з використання застарілі?
12. Яка різниця між `Promise.all()` і `Promise.allSettled()`?
13. Яка різниця між `f2` і `f3` у такому виразі: `promiseInstance.then(f1, f2).catch(f3)`?
14. Коли і чому ми можемо мати кілька викликів catch: `promiseInstance.catch(f1).catch(f2).catch(f3)`?
15. Чому ми маємо метод `Promise` `finally` і які можуть бути варіанти його використання?
16. Як ми можемо написати асинхронний код за допомогою синхронних генераторів? Які переваги та недоліки цього підходу?
17. Наведіть приклади використання `yield` в асинхронному програмуванні. Як це переписати на сучасному JavaScript?
18. Опишіть відмінності між Web Workers, Shared Workers і Worker Threads.
19. Розкажіть, що таке мікрозадачі та макрозадачі та який вони мають зв'язок із циклом подій?
20. Що таке Worker Threads в Node.js і як ми можемо використовувати їх?
21. Як ми можемо виміряти продуктивність I/O операцій та використання ними ресурсів?
22. Що таке `process.hrtime` і `process.hrtime.bigint()`? В чому різниця?
23. Розкажіть нам про такий API Node.js: `const { performance } = require('node:perf_hooks');`
24. Як ми можемо ефективно обробляти асинхронні запити API на стороні клієнта, які повертають великі обсяги даних?
25. Як ми можемо ефективно обробляти запити API на стороні сервера, які асинхронно повертають великі обсяги даних?
26. Як ми можемо забезпечити ізоляцію стану між різними асинхронними запитами в одному процесі Node.js?
27. Що таке CLS (continuation local storage) і чи є у нас сучасна заміна цій техніці в Node.js?
28. Які фази циклу подій пов'язані з незавершеними зворотними викликами?
29. Розкажіть про контракт `Thenable` і його відношення до `Promise`.
30. Як ми можемо пов'язати дані (стан, колекції, структури даних) із ланцюгом асинхронних викликів?
31. Як ми можемо відстежувати ланцюжок асинхронних викликів із зовнішніх запитів (які йдуть від виклику API через HTTP, UDP, IPC, WebSocket)?
32. Як ми можемо забезпечити безпечну обробку конкуруючих запитів до ресурсу?
33. Навіщо нам потрібні блокування, наприклад Web Locks?
34. Як ми можемо використовувати примітиви паралельного програмування (semaphore, mutex, critical section тощо) в асинхронному програмуванні?
35. Розкажіть про парадигму «Реактивного програмування».
36. Яка різниця між підходами потоків та сигналів у реактивному програмуванні?
37. Як ми можемо уникати deadlocks чи виходити з такого стану в асинхронному коді?
38. Як ми можемо забезпечити високу доступність в асинхронних програмах?
39. Як ми можемо обробляти асинхронні операції, які залежать одна від одної (паралельне та послідовне виконання)?
40. Що таке «race condition», і як ми можемо цього уникати?
41. Надайте випадки використання для `Promise.race`, `Promise.all` і `Promise.allSettled`.
42. Що таке throttling та debouncing в контексті асинхронного програмування?
43. Як ми можемо зашейпити (обмежити) асинхронні виклики (наприклад, щоб краще обробляти потік запитів до API)?
44. Які абстракції, що реалізують шаблон `Observable`, ми маємо в JavaScript для серверної та зовнішньої частини?
45. Опишіть підхід `Signals` для реактивного коду.
46. Чому `Streams` корисні для покращення семантики коду як абстракції високого рівня?
47. Що таке «back pressure»?
48. Яка різниця між створенням `Stream` за допомогою `extends` і передачею функції `read`, `write` або `transform` до конструктору?
49. Чому ми маємо три набори таймерів: у глобальному контексті (наприклад, `setTimeout`), `node:timers` і `node:timers.promises`?
50. Які promisified API ви знаєте, і як ми можемо вручну promisify інші API?
51. Розкажіть про тестування асинхронного коду.
52. Чому TypeScript не може описати асинхронні контракти в усіх аспектах?
53. Як ми можемо запобігти витокам пам'яті (memory leaks) в асинхронному коді?
54. Які найкращі методи (best practices) керування паралелізмом у JavaScript?
55. Як ми можемо використовувати async/await з `EventEmitter`?
56. Яка різниця між `EventEmitter` і `EventTarget`?
57. Яка роль ключового слова `await` в асинхронних функціях?
58. Що станеться, якщо ми використаємо `await` не з `Promise` значеннями (або виразами)?
59. Як ми можемо додати тайм-аути в асинхронних операціях (включаючи синтаксис `await`)?
60. Для чого використовується метод `process.nextTick`?
61. Як ми можемо створити власні асинхронні ітератори та які варіанти їх використання?
62. Які переваги та недоліки використання асинхронних бібліотек сторонніх розробників, таких як поліфіли для `Promise` чи `async.js`?
63. Як ми можемо працювати з асинхронним кодом у застарілих системах?
64. Яка різниця між асинхронними, паралельними та I/O операціями?
65. Як ми можемо ефективно розпаралелювати I/O операції?
66. Як ми можемо забезпечити потоко-безпечність в асинхронному програмуванні?
67. Як `Atomics` пов'язані з асинхронним і паралельним програмуванням? Для чого вони використовуються?
68. Як ми можемо оптимізувати асинхронний код для продуктивності (performance)?
69. Як ми можемо обробляти повтори (retries) викликів, обчислень, доступу до ресурсів в асинхронному програмуванні?
70. Які типові підводні камені асинхронного програмування?
71. Як ми можемо використовувати async/await функції з `Array.prototype.map`?
72. Як ми можемо ефективно дебажити асинхронний код?
73. Як ми можемо забезпечити узгодженість даних в асинхронних операціях?
74. Які переваги використання `async/await` над зворотними викликами (callbacks)?
75. Які операції не можна переписати з зворотних викликів (callbacks) на синтаксис `async/await` (але можливі з `Promises`)?
76. Запропонуйте випадки використання для `AbortSignal.timeout()`. Які відомі API це підтримують?
77. Де і для яких цілей ми можемо використовувати `AbortSignal.any(iterable)`?
78. Які відмінності між методами `Promise`: `resolve` і `reject`?
79. Як ми можемо обробляти помилки в `Promise.all`?
80. Як ми можемо chain (послідовно композувати) асинхронні операції? (Будь ласка, запропонуйте випадки для тих контрактів, які знаєте)
81. Яка роль event loop в асинхронному програмуванні?
82. Як ми можемо обробляти тривалі асинхронні операції? (Процеси можуть припинити роботу, результати можуть застаріти тощо)
83. Як ми можемо забезпечити ідемпотентність в асинхронних операціях і коли нам це потрібно?
84. Чи можемо ми написати програму реального часу на JavaScript і асинхронному програмуванні?
85. Як ми можемо забезпечити порядок асинхронних операцій? Будь ласка, підкажіть випадки, коли ми можемо мати проблеми.
86. Як ми можемо працювати з асинхронним кодом у системах високої доступності?
87. Що таке «observables» і як ми можемо їх використовувати в JavaScript?
88. Які основні проблеми обробки стану в асинхронному коді в stateful системах?
89. Коли ми можемо використовувати внутрішні асинхронні черги, а коли нам потрібні зовнішні системи черг?
90. Як ми можемо використовувати асинхронні функції з кешуванням, memoization, та повторними обчисленнями для оновлення стану?
91. Як ми можемо використовувати асинхронні функції з підключеннями до бази даних і які юз кейси?
92. Як ми можемо відокремити асинхронний код від бізнес-логіки і чому нам потрібно це робити?
93. Який вплив асинхронного коду на операції, пов'язані з процесором, а не на I/O операції?
94. Які речі у асинхронному програмуванні потрібно робити з міркувань безпеки?
95. Як ми можемо реалізувати чергу за пріоритетами для асинхронних завдань?
96. Як ми можемо використовувати асинхронні функції з операціями файлової системи?
97. Як ми можемо забезпечити атомарність в асинхронних операціях і для чого?
98. Які компроміси між використанням `Promise` і `async/await`?
99. Яка різниця між класичним асинхронним програмуванням і підходом RxJS?
100. Що таке асинхронні колекції та як вони можуть покращити роботу розробника?

## Посилання

- [ Каталог питань на інтерв'ю](https://github.com/tshemsedinov/Interview-Questions)
- [ Async 2024](https://github.com/HowProgrammingWorks/Index/blob/master/Courses/Async-2024.md)
- [ Node.js 2024](https://github.com/HowProgrammingWorks/Index/blob/master/Courses/NodeJS-2024.md)
- [ Self Assessment](https://github.com/HowProgrammingWorks/SelfAssessment)
